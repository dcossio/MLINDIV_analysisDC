---
title: "MIDLIFE TBSS"
author: "Daniela Cossio"
date: "09/14/2023"
output:
   html_document:
    toc: true
    toc_float: true
    toc_depth: 6
    theme: flatly
editor_options: 
  chunk_output_type: inline
---

```{css, echo=FALSE}
h1, h2 {
  text-align: center;
```

# Overview 
This is the analysis of white matter using FSLs TBSS

<br>

# <span style="color: darkblue;">Methods </span> 

**Participants** 

  * Total number of scans = 120 (males and females)  
  
  * Total scans used in analysis= 118  
  * Excluded subs 329 and 372 from analyses due to bad behavior data and Subject 347 failed quality 
  control check in DSI

<br>

  **Scan parameters** 

  * Locations from UCSB and UCI
<br>

**QSIprep** 

  * Version used: 0.16.0RC3

  * The following parameters were used
    * dwi_denoise_window **5** 
    * hmc_model **3dSHORE** 
    * hmc-transform **Rigid** 
    * shoreline_iters **2**
<br>

**Preprocessing for FSL** 

The data needs to be reconstructed and prepared for FSL.

  * Run FSL dti fit in order to extract our statistics. It fits a tensor model at each voxel.
    * You need the following inputs 
      * DWI scan images
      * BRain mask image
      * Output name 
      * Bvec files
      * B value files
      
  * We need to reorient the images to be in the same format as FSL atlases. 
    * We run FSL reorient on each image 

<br>
**FSL TBSS**

  * **Step 1:** tbss _1_preproc *nii.gz
    * this prepares the data for full preprocessing 
    
    <br>
  * **Step 2:** tbss_2_reg
    * This runs a nonlinear registration and creates transforms of all the images in order to put them into a standard space 
    
    <br>
  * **Step 3:** tbss_3_postreg
    * Applies all of the transofrms created in the previous step
    
    <br>
  * **Intermediate Step:** Quality check
    * Open all images in FSL and visually inspect that they line up with the mean FA 
    
    <br>
  * **Step 4:** tbss_4_prestats
    * Creates a threshold for each of the masks in order to extract stats 
    
    <br>
  * **Custom scripts** 
    * here we use custoim fsl maths and meants scripts in order to extract our values for the JHU atlas
    
<br><br>

# Results 

```{r Load Libraries, echo=FALSE, results='hide',message=FALSE }
library(ggplot2)
#(plyr)
library(tidyverse)
# library(dplyr)
# library(tidyr)
library(stringr)
library(kableExtra)
# library(data.table)
# library(network)
# library(tidygraph)
# library(ggraph)
# library(igraph)
# library(networkD3)
# library(CINNA)
# library(umap)
# library(plotly)
#library(factoextra)
#library(lsr)
# library(car)
library(ggpubr)
#library(entropy)
#library(ds4psy)
# library(pROC)
#library(devtools)
#library(BRRR)
#library(stats)
#library(afex)
library(knitr)
library(janitor)
library(car)
library(ggiraph)
library(ggiraphExtra)
library(moonBook)
library(nationalparkcolors)
library(gridExtra)
library(markdown)
library(ppcor)
library(mediation)

```

```{r, Functions for analyses, echo=FALSE, results='hide',message=FALSE}

CheckDistribution <- function(dataframe,threshold){
  
  # Purpose of this is to take in a tbss csv dataframe and checking the distribution of each ROI. Then it spits out all the regions that are not normally distributed. 
  normality_check<- data.frame(matrix(ncol = 2, nrow = 0))

  for (roi in c(ROIs$V2)){
    
    df <- data.frame(matrix(ncol = 2, nrow = 1))
    
    normcheck <- shapiro.test(dataframe[[roi]])
    
    if (normcheck[["p.value"]] < threshold) {

      df$X1 <- roi
      df$X2 <- normcheck[["p.value"]]
      # 
      normality_check <- rbind(normality_check,df)
    }
  }
  
  colnames(normality_check) <- c("ROI","p.value")
  return(normality_check)
}


# Craeting tables for html
TableOutput <- function(df){
  knitr::kable(df, row.names=F) %>% 
  kable_styling(bootstrap_options =  c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "600px", height = "300px") 
}



RunningPcorTest <- function(dataframe, task, covariates){
  

  # Here we need a clean dataframe that contains only on wm metric (FA,AD,RD, MD) and it needs to be combined with the subject info data that we need. here i need maze accuracy, sex, and age. Also, need to remove any rows with NW
  
  finalDF <-   data.frame(matrix(ncol = 7, nrow = 0))
  
  for (roi in c(ROIs$V2)){
    
    df <- data.frame(matrix(ncol = 6, nrow = 1))
    
    pcortestresults <-pcor.test(dataframe[[roi]],dataframe[[task]], dataframe[, c(covariates)])
    
    if (pcortestresults$p.value < 0.05) {

      df$X1 <- roi
      df[,2:7] <- pcortestresults
      # 
      finalDF <- rbind(finalDF,df)
    }
  }
  colnames(finalDF) <- c("ROI", colnames(pcortestresults))
  return(finalDF)
}

AprioriPcorTest <-  function(dataframe,task, covariates){
  
  # Here we have our list of ROIS
  list_rois <- c("fornix_body", "fornix_R", "fornix_L","Cingulum_(cingulate_gyrus)_R","Cingulum_(cingulate_gyrus)_L","Cingulum_(hippocampus)_R", "Cingulum_(hippocampus)_L")


  DF <-dataframe %>% filter(!is.na(dataframe[[task]]))
  finalDF <- data.frame(matrix(ncol = 7, nrow = 0))

 for (roi in c(list_rois)){
    df <- data.frame(matrix(ncol = 6, nrow = 1))
    
    pcortestresults <- pcor.test(DF[[roi]],DF[[task]],DF[, c(covariates)],method = "spearman")
    #
    df$X1 <- roi
    df[,2:7] <- pcortestresults
    #   # 
    finalDF <- rbind(finalDF,df)
    # 
 }
  colnames(finalDF) <- c("ROI", colnames(pcortestresults))
  return(finalDF)

}


GetAprioriDF <- function(dataframe){
  
  # List of a prior rois 
  apriori_ROIS <- c("Fornix_(column_and_body_of_fornix)","Fornix_(cres)_/_Stria_terminalis_(can_not_be_resolved_with_current_resolution)_R","Fornix_(cres)_/_Stria_terminalis_(can_not_be_resolved_with_current_resolution)_L", "Cingulum_(cingulate_gyrus)_R","Cingulum_(cingulate_gyrus)_L","Cingulum_(hippocampus)_R", "Cingulum_(hippocampus)_L")
  
  # clean up the names 
  df <- dataframe %>% dplyr::select(. ,apriori_ROIS) %>% `colnames<-`(c("fornix_body", "fornix_R", "fornix_L","Cingulum_(cingulate_gyrus)_R","Cingulum_(cingulate_gyrus)_L","Cingulum_(hippocampus)_R", "Cingulum_(hippocampus)_L"))
  
  return(df)
}




```

```{r REad in our CSVS, echo=FALSE, results='hide',message=FALSE}

# Lets read in our subject information
top_workdir <-"/Users/danielacossio/Documents/Chrastil_Lab/Projects/SNAG/MIDLIFE_TBSS/"
  # laptop path "/Users/danielacossio/Library/CloudStorage/GoogleDrive-dcossio1@uci.edu/Other computers/My iMac/Chrastil_Lab/Projects/SNAG/MIDLIFE_TBSS/"

ROIs <- read.table(paste0(top_workdir,"JHU-WhiteMatter-labels-1mm.txt")) %>% dplyr::select(V2)

sub_info_master <- read.csv(paste0(top_workdir,"subject_info.csv"))

master_FA <- read.csv(paste0(top_workdir,"JHU-skeletonized-FA.csv"), header=FALSE) %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2)) 

master_MD <- read.csv(paste0(top_workdir,"JHU-skeletonized-MD.csv"))  %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2))

master_AD <- read.csv(paste0(top_workdir,"JHU-skeletonized-AD.csv")) %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2))

master_RD <- read.csv(paste0(top_workdir,"JHU-skeletonized-RD.csv")) %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2))



```

### Overall approach 
First, I will run analysis using our aprior rois 
  - Fornix 
  - Cingulum bundle (L and R) 
  
Here, I will run a partial correlation and control for sex and age. Then I will run a multiple linear regression using sex and age as covariates. Then If there is a sex effect, I will run a sex stratisfied analysis using a partial correlation and controlling for age. 

## <span style="color: darkorange;"> Behavior Distributions </span>  {.tabset} 

### Maze Accuracy 

```{r, echo=FALSE,results='hide', message=FALSE, out.width="50%"}

# All
ggplot(sub_info_master, aes(x= maze_accuracy_pct)) +
  geom_histogram()


#By sex
ggplot(sub_info_master, aes(x= maze_accuracy_pct, fill =sex, color=sex)) +
  geom_histogram()


```
<br>

Let's just double check that by running a normality test.  
```{r,echo=FALSE, results='hide', message=FALSE}
#Normality Check
maze_norm <- shapiro.test(sub_info_master$maze_accuracy_pct)
maze_norm[["p.value"]]
```

The data is not normally distributed with p = `r maze_norm[["p.value"]]`.


### DSP
```{r, echo=FALSE,results='hide', message=FALSE, out.width="50%"}

# All
ggplot(sub_info_master, aes(x= dsp_si_true_pct)) +
  geom_histogram()


#By sex
ggplot(sub_info_master, aes(x= dsp_si_true_pct, fill =sex, color=sex)) +
  geom_histogram()
```

<br>

Let's just double check that by running a normality test.  
```{r,echo=FALSE, results='hide', message=FALSE}
#Normality Check
DSP_norm <- shapiro.test(sub_info_master$dsp_si_true_pct)
DSP_norm[["p.value"]]
```

### Loop

#### AE
Average
```{r, echo=FALSE,results='hide', message=FALSE, out.width="50%"}

# All
ggplot(sub_info_master, aes(x= loop_ae_avg_degree)) +
  geom_histogram()

#By sex
ggplot(sub_info_master, aes(x= loop_ae_avg_degree, fill =sex, color=sex)) +
  geom_histogram()
```

Rad3
```{r, echo=FALSE,results='hide', message=FALSE, out.width="50%"}

# All
ggplot(sub_info_master, aes(x= loop_ae_rad3_degree)) +
  geom_histogram()

#By sex
ggplot(sub_info_master, aes(x= loop_ae_rad3_degree, fill =sex, color=sex)) +
  geom_histogram()
```

#### DE
#### PE



## <span style="color: darkorange;"> FA </span>  {.tabset} 

### Apriori
First, let's start with our apriori regions: Fornix body fornix (L and R), Cingulum bundle (cingulate gyrus and hippocampus ) L and R. 

```{r, echo=FALSE,results='hide', message=FALSE }
#  Creating our data frame  by taking apriori rois and also renaming them for a clean name and binding them with or subject information
apriori_FA <- GetAprioriDF(master_FA) %>% cbind(sub_info_master, .)
```

#### Maze Accuracy

##### Partial Correlations

Here we want to know whether ROIs correlate to our different behavioral variables when we control for age and sex. So we will run partial correlations.
```{r, echo=FALSE,results='hide', message=FALSE }
FA_maze_results <- AprioriPcorTest(dataframe = apriori_FA, task ="maze_accuracy_pct",covariates = c("sex.1","age_scan_years"))
TableOutput(FA_maze_results)

```

Nothing significantly correlated for maze accuracy. 

##### Multiple Linear Regression
```{r, echo=FALSE,results='hide', message=FALSE }
# Fornix
model1 <- lm(maze_accuracy_pct ~ fornix_body + sex.1 + age_scan_years, data = apriori_FA)
summary(model1)

model2 <- lm(maze_accuracy_pct ~ fornix_R + sex.1 + age_scan_years, data = apriori_FA)
summary(model2)

model3 <- lm(maze_accuracy_pct ~ fornix_L + sex.1 + age_scan_years, data = apriori_FA)
summary(model3)


model4 <- lm(maze_accuracy_pct ~ `Cingulum_(cingulate_gyrus)_R` + sex.1 + age_scan_years, data = apriori_FA)
summary(model4)


model5 <- lm(maze_accuracy_pct ~ `Cingulum_(cingulate_gyrus)_L` + sex.1 + age_scan_years, data = apriori_FA)
summary(model5)

model6 <- lm(maze_accuracy_pct ~ `Cingulum_(hippocampus)_R` + sex.1 + age_scan_years, data = apriori_FA)
summary(model6)

model7 <- lm(maze_accuracy_pct ~ `Cingulum_(hippocampus)_L` + sex.1 + age_scan_years, data = apriori_FA)
summary(model7)



```

Age appears to be the larger factor here not sex or even ROI in predicting maze accuracy behavior.

##### Sex Stratified partial correlations






## <span style="color: darkorange;"> MD </span>  {.tabset .tabset-dropdown}  