---
title: "MIDLIFE TBSS"
author: "Daniela Cossio"
date: "09/14/2023"
output:
   html_document:
    toc: true
    toc_float: true
    toc_depth: 6
    theme: flatly
editor_options: 
  chunk_output_type: inline
---

```{css, echo=FALSE}
h1, h2 {
  text-align: center;
```

# Overview 
This is the analysis of white matter using FSLs TBSS

<br>

# <span style="color: darkblue;">Methods </span> 

**Participants** 

  * Total number of scans = 120 (males and females)  
  
  * Total scans used in analysis= 118  
  * Excluded subs 329 and 372 from analyses due to bad behavior data and Subject 347 failed quality 
  control check in DSI

<br>

  **Scan parameters** 

  * Locations from UCSB and UCI
<br>

**QSIprep** 

  * Version used: 0.16.0RC3

  * The following parameters were used
    * dwi_denoise_window **5** 
    * hmc_model **3dSHORE** 
    * hmc-transform **Rigid** 
    * shoreline_iters **2**
<br>

**Preprocessing for FSL** 

The data needs to be reconstructed and prepared for FSL.

  * Run FSL dti fit in order to extract our statistics. It fits a tensor model at each voxel.
    * You need the following inputs 
      * DWI scan images
      * BRain mask image
      * Output name 
      * Bvec files
      * B value files
      
  * We need to reorient the images to be in the same format as FSL atlases. 
    * We run FSL reorient on each image 

<br>
**FSL TBSS**

  * **Step 1:** tbss _1_preproc *nii.gz
    * this prepares the data for full preprocessing 
    
    <br>
  * **Step 2:** tbss_2_reg
    * This runs a nonlinear registration and creates transforms of all the images in order to put them into a standard space 
    
    <br>
  * **Step 3:** tbss_3_postreg
    * Applies all of the transofrms created in the previous step
    
    <br>
  * **Intermediate Step:** Quality check
    * Open all images in FSL and visually inspect that they line up with the mean FA 
    
    <br>
  * **Step 4:** tbss_4_prestats
    * Creates a threshold for each of the masks in order to extract stats 
    
    <br>
  * **Custom scripts** 
    * here we use custoim fsl maths and meants scripts in order to extract our values for the JHU atlas
    
<br><br>

# Results 

```{r Load Libraries, echo=FALSE, results='hide',message=FALSE }
library(ggplot2)
#(plyr)
library(tidyverse)
# library(dplyr)
# library(tidyr)
library(stringr)
library(kableExtra)
# library(data.table)
# library(network)
# library(tidygraph)
# library(ggraph)
# library(igraph)
# library(networkD3)
# library(CINNA)
# library(umap)
# library(plotly)
#library(factoextra)
#library(lsr)
# library(car)
library(ggpubr)
#library(entropy)
#library(ds4psy)
# library(pROC)
#library(devtools)
#library(BRRR)
#library(stats)
#library(afex)
library(knitr)
library(janitor)
library(car)
library(ggiraph)
library(ggiraphExtra)
library(moonBook)
library(nationalparkcolors)
library(gridExtra)
library(markdown)
library(ppcor)
library(mediation)

```

```{r, Functions for analyses, echo=FALSE, results='hide',message=FALSE}

CheckDistribution <- function(dataframe,threshold){
  normality_check<- data.frame(matrix(ncol = 2, nrow = 0))

  for (roi in c(ROIs$V2)){
    
    df <- data.frame(matrix(ncol = 2, nrow = 1))
    
    normcheck <- shapiro.test(dataframe[[roi]])
    
    if (normcheck[["p.value"]] < threshold) {

      df$X1 <- roi
      df$X2 <- normcheck[["p.value"]]
      # 
      normality_check <- rbind(normality_check,df)
    }
  }
  
  colnames(normality_check) <- c("ROI","p.value")
  return(normality_check)
}


# Craeting tables for html
TableOutput <- function(df){
  knitr::kable(df, row.names=F) %>% 
  kable_styling(bootstrap_options =  c("striped", "hover", "condensed")) %>% 
  scroll_box(width = "600px", height = "300px") 
}



RunningPcorTest <- function(dataframe, task, covariates){
  

  # Here we need a clean dataframe that contains only on wm metric (FA,AD,RD, MD) and it needs to be combined with the subject info data that we need. here i need maze accuracy, sex, and age. Also, need to remove any rows with NW
  finalDF <-   data.frame(matrix(ncol = 7, nrow = 0))
  
  for (roi in c(ROIs$V2)){
    
    df <- data.frame(matrix(ncol = 6, nrow = 1))
    
    pcortestresults <-pcor.test(dataframe[[roi]],dataframe[[task]], dataframe[, c(covariates)])
    
    if (pcortestresults$p.value < 0.05) {

      df$X1 <- roi
      df[,2:7] <- pcortestresults
      # 
      finalDF <- rbind(finalDF,df)
    }
  }
  colnames(finalDF) <- c("ROI", colnames(pcortestresults))
  return(finalDF)
}

```

```{r REad in our CSVS, echo=FALSE, results='hide',message=FALSE}

# Lets read in our subject information
top_workdir <-"/Users/danielacossio/Documents/Chrastil_Lab/Projects/SNAG/MIDLIFE_TBSS/"
  # laptop path "/Users/danielacossio/Library/CloudStorage/GoogleDrive-dcossio1@uci.edu/Other computers/My iMac/Chrastil_Lab/Projects/SNAG/MIDLIFE_TBSS/"

ROIs <- read.table(paste0(top_workdir,"JHU-WhiteMatter-labels-1mm.txt")) %>% dplyr::select(V2)

sub_info_master <- read.csv(paste0(top_workdir,"subject_info.csv"))

master_FA <- read.csv(paste0(top_workdir,"JHU-skeletonized-FA.csv"), header=FALSE) %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2)) 

master_MD <- read.csv(paste0(top_workdir,"JHU-skeletonized-MD.csv"))  %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2))

master_AD <- read.csv(paste0(top_workdir,"JHU-skeletonized-AD.csv")) %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2))

master_RD <- read.csv(paste0(top_workdir,"JHU-skeletonized-RD.csv")) %>% remove_empty(. ,which = "cols") %>% `colnames<-`(c(ROIs$V2))



```

### Overall approach 


## <span style="color: darkorange;"> FA </span>  {.tabset} 

First, Let me plot and check all of our FA data 

### histograms for ROIs
```{r, echo=FALSE, message=FALSE,fig.show="hold", out.width="50%"}

FA_df <- cbind(sub_info_master, master_FA)

# Let's plot a visualization of all of our ROIs
rois <- colnames(master_FA)


for (roi in rois){
  hist(FA_df[roi])
}


```

### histograms for ROIs split by sex

```{r, echo=FALSE, message=FALSE,fig.show="hold", out.width="50%"}

# Let's plot a visualization of all of our ROIs
rois <- colnames(master_FA)
for (roi in rois){
  print(ggplot(FA_df, aes(x=.data[[roi]], fill =sex, color=sex)) +
  geom_histogram())
}


```

### Scatter plots against age for ROIs
```{r, echo=FALSE, message=FALSE,fig.show="hold", out.width="50%"}

# Let's plot a visualization of all of our ROIs
rois <- colnames(master_FA)

for (roi in rois){
  print(ggplot(FA_df, aes(x= age_scan_years, y= .data[[roi]])) + geom_point() + geom_smooth(method=lm))
}

```


### Maze Accuracy {.tabset}
```{r, setting up a df to combine FA with maze accuracy, echo=FALSE,results='hide', message=FALSE }

temp_subinfo <- sub_info_master %>% dplyr::select(subject_id,age_group,age_scan_years,maze_accuracy_pct,maze_moves,maze_path_efficiency,sex.1,repo_status,FNAME)

FA_maze <-cbind(temp_subinfo,master_FA) %>% filter(!is.na(maze_accuracy_pct))

```

Let's look at the distribution for maze accuracy behavior. Data appears to be not normally distributed.
```{r, echo=FALSE,results='hide', message=FALSE, out.width="50%"}

# All
ggplot(FA_maze, aes(x= maze_accuracy_pct)) +
  geom_histogram()


#By sex
ggplot(FA_maze, aes(x= maze_accuracy_pct, fill =sex, color=sex)) +
  geom_histogram()


```

Let's just double check that by running a normality test.  
```{r,echo=FALSE, results='hide', message=FALSE}
#Normality Check
maze_norm <- shapiro.test(FA_maze$maze_accuracy_pct)
maze_norm[["p.value"]]
```

The data is not normally distributed with p = `r maze_norm[["p.value"]]`.

<br>

Before getting started, lets change the the accuracy to a log 

```{r, echo=FALSE,results='hide', message=FALSE }

FA_maze[FA_maze$maze_accuracy_pct == 0.00000000,] <- 0.00000001


L_acc <- log(FA_maze$maze_accuracy_pct/(1-FA_maze$maze_accuracy_pct))


```



### Checking independency 

```{r, echo=FALSE,results='hide', message=FALSE}

model <- aov(maze_accuracy_pct ~ sex.1, data = FA_maze)
summary(model)


```



#### Checking normality
```{r, normality check FA,echo=FALSE, message=FALSE}
#Normality Check
x <- CheckDistribution(FA_maze,0.05)
TableOutput(x)
```

#### partial correlations

Running semi correlations using ppcor sex and age are covariates
```{r FA_maze acc PPCOR, echo=FALSE, message=FALSE}

FA_maze_results <-  RunningPcorTest(dataframe = FA_maze,task = "maze_accuracy_pct",covariates = c("age_scan_years","sex.1"))

TableOutput(FA_maze_results)
```

<!-- Multiple linear regression -->
<!-- ```{r} -->
<!-- fit <- lm(maze_accuracy_pct ~ Middle_cerebellar_peduncle * age_scan_years + sex.1, data = FA_maze) -->

<!-- summary(fit) -->
<!-- ``` -->



 


#### Mediation analysis
We want to know whether sex mediates the relationship between FA and Maze Accuracy in midlife adults. in this case X= ACC, Y = FA and M = sex. Looks like Sex does not mediate the effect of FA on ACC in middle cerebellar peduncle. 

1. Let's run a linear model using FA and Acc.  
```{r, echo=FALSE,results='hide', message=FALSE}

# Effect on accuracy
mod1 <- lm(FA_maze$Middle_cerebellar_peduncle ~ FA_maze$maze_accuracy_pct)
summary(mod1)

# effect on sex 
mod2 <- lm(FA_maze$sex.1 ~ FA_maze$maze_accuracy_pct)
summary(mod2)

mod3 <- lm(FA_maze$Middle_cerebellar_peduncle ~ FA_maze$maze_accuracy_pct + FA_maze$sex.1)
summary(mod3)

# sex does not mediate this effect 
med_results <- mediate(mod2, mod3, treat='FA_maze$maze_accuracy_pct', mediator='FA_maze$sex.1')
summary(med_results)
```

### DSP  {.tabset}

```{r, setting up a df to combine FA with DSP SI, echo=FALSE,results='hide', message=FALSE }

temp_subinfo <- sub_info_master %>% dplyr::select(subject_id,age_group,age_scan_years,dsp_si_true_pct,sex.1,repo_status,FNAME)

FA_DSP <-cbind(temp_subinfo,master_FA) %>% filter(!is.na(dsp_si_true_pct))

```
#### partial correlations
Running semi correlations using ppcor sex and age are covariates
```{r FA_DSP PPCOR, echo=FALSE, message=FALSE}

FA_DSP_results <-  RunningPcorTest(dataframe = FA_DSP,task = "dsp_si_true_pct",covariates = c("age_scan_years","sex.1"))

TableOutput(FA_DSP_results)
```

```{r, echo=FALSE,results='hide', message=FALSE}

 fit <- lm(sex.1 ~ `Fornix_(cres)_/_Stria_terminalis_(can_not_be_resolved_with_current_resolution)_R`, data = FA_DSP)
summary(fit)
```





## <span style="color: darkorange;"> MD </span>  {.tabset .tabset-dropdown}  